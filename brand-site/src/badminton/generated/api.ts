/* tslint:disable */
/* eslint-disable */
/**
 * Badminton Service API
 * Backend API for managing badminton groups, participants, matches and ratings (Elo).  Roles: - **User**: registers via Telegram, views own stats/ratings, views own groups, creates new groups. - **Group admin**: manages participants, links registered users to participants, manages match results. 
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ErrorResponse {
    'timestamp': string;
    'message': string;
    'path': string;
}
export interface GameScore {
    'pointsA': number;
    'pointsB': number;
}
export interface Group {
    'id': string;
    'name': string;
    'createdAt': string;
    'createdByUserId'?: string;
    /**
     * Role of current user in this group
     */
    'myRole'?: GroupMyRoleEnum;
}

export const GroupMyRoleEnum = {
    Member: 'member',
    Admin: 'admin'
} as const;

export type GroupMyRoleEnum = typeof GroupMyRoleEnum[keyof typeof GroupMyRoleEnum];

export interface GroupCreateRequest {
    'name': string;
}
export interface GroupPage {
    'items': Array<Group>;
    'nextCursor'?: string | null;
}
export interface GroupStats {
    'groupId': string;
    'totalMatches': number;
    'lastMatchAt'?: string | null;
}
export interface LinkUserRequest {
    'userId': string;
}
export interface Match {
    'id': string;
    'groupId': string;
    'kind': MatchKind;
    'startedAt': string;
    'notes'?: string;
    'teamA': Array<string>;
    'teamB': Array<string>;
    'score': MatchScore;
    'createdAt': string;
    'createdByUserId'?: string;
}


export interface MatchCreateRequest {
    'kind': MatchKind;
    /**
     * Match start time. If not provided, backend sets current time.
     */
    'startedAt'?: string | null;
    'notes'?: string;
    'teamA': Array<string>;
    'teamB': Array<string>;
    'score': MatchScore;
}



export const MatchKind = {
    Singles: 'singles',
    Doubles: 'doubles'
} as const;

export type MatchKind = typeof MatchKind[keyof typeof MatchKind];


export interface MatchPage {
    'items': Array<Match>;
    'nextCursor'?: string | null;
}
/**
 * Match score as list of games. Each game has pointsA and pointsB. 
 */
export interface MatchScore {
    'games': Array<GameScore>;
}
export interface MatchUpdateRequest {
    'startedAt'?: string;
    'notes'?: string;
    'teamA'?: Array<string>;
    'teamB'?: Array<string>;
    'score'?: MatchScore;
}
export interface Participant {
    'id': string;
    'groupId': string;
    'name': string;
    /**
     * Linked registered user id (if any)
     */
    'userId'?: string | null;
    'createdAt': string;
}
export interface ParticipantCreateRequest {
    'name': string;
}
/**
 * Paginated search result for participants
 */
export interface ParticipantSearchResult {
    'items': Array<Participant>;
    /**
     * Current page number (0-based)
     */
    'page': number;
    /**
     * Number of items per page
     */
    'pageSize': number;
    /**
     * Total number of matching participants
     */
    'total': number;
    /**
     * Whether there are more pages available
     */
    'hasMore': boolean;
}
export interface ParticipantUpdateRequest {
    'name'?: string;
}
/**
 * Elo for a pair. pairKey can be stable concatenation of sorted participant ids. 
 */
export interface RatingRowDoubles {
    'pairKey': string;
    'participantIds': Array<string>;
    'participantNames': Array<string>;
    'elo': number;
    'games': number;
}
export interface RatingRowSingles {
    'participantId': string;
    'participantName': string;
    'elo': number;
    'games': number;
}
export interface RefreshRequest {
    'refreshToken': string;
}
export interface StatsBlock {
    'matchesPlayed': number;
    'matchesWon': number;
    'matchesLost': number;
    'winRate': number;
}
export interface TelegramUser {
    'id': number;
    'first_name'?: string;
    'last_name'?: string;
    'username'?: string;
    'photo_url'?: string;
    'auth_date': number;
    'hash': string;
}
export interface TokenResponse {
    'accessToken': string;
    'refreshToken': string;
}
export interface User {
    'id': string;
    'telegramId': number;
    'username'?: string;
    'displayName'?: string;
    'createdAt': string;
}
/**
 * Extended user stats with recent matches
 */
export interface UserGamesStats {
    'userId': string;
    'singles': StatsBlock;
    'doubles': StatsBlock;
    /**
     * Recent matches involving the user
     */
    'recentMatches': Array<Match>;
}
export interface UserRatings {
    'userId': string;
    /**
     * Current singles Elo (in selected group or global aggregation)
     */
    'singlesElo': number;
    /**
     * Doubles Elo ratings grouped by partner
     */
    'doublesByPartner': Array<UserRatingsDoublesByPartnerInner>;
}
export interface UserRatingsDoublesByPartnerInner {
    'partnerUserId': string;
    'partnerName': string;
    'games': number;
    'wins': number;
    'losses': number;
    'elo': number;
}
export interface UserStats {
    'userId': string;
    'singles': StatsBlock;
    'doubles': StatsBlock;
}

/**
 * GroupsApi - axios parameter creator
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get group by id (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdGet', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Same as /groups (alias for convenience)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGroupsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new group
         * @param {GroupCreateRequest} groupCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (groupCreateRequest: GroupCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupCreateRequest' is not null or undefined
            assertParamExists('createGroup', 'groupCreateRequest', groupCreateRequest)
            const localVarPath = `/api/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List groups where current user is a member (via linked participant)
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get group by id (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.apiGroupsGroupIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Same as /groups (alias for convenience)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeGroupsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeGroupsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.apiMeGroupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new group
         * @param {GroupCreateRequest} groupCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(groupCreateRequest: GroupCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(groupCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List groups where current user is a member (via linked participant)
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.listGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get group by id (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.apiGroupsGroupIdGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Same as /groups (alias for convenience)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGroupsGet(options?: RawAxiosRequestConfig): AxiosPromise<GroupPage> {
            return localVarFp.apiMeGroupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new group
         * @param {GroupCreateRequest} groupCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(groupCreateRequest: GroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.createGroup(groupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List groups where current user is a member (via linked participant)
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupPage> {
            return localVarFp.listGroups(limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - interface
 */
export interface GroupsApiInterface {
    /**
     * 
     * @summary Get group by id (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Group>;

    /**
     * 
     * @summary Same as /groups (alias for convenience)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMeGroupsGet(options?: RawAxiosRequestConfig): AxiosPromise<GroupPage>;

    /**
     * 
     * @summary Create new group
     * @param {GroupCreateRequest} groupCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(groupCreateRequest: GroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Group>;

    /**
     * 
     * @summary List groups where current user is a member (via linked participant)
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupPage>;

}

/**
 * GroupsApi - object-oriented interface
 */
export class GroupsApi extends BaseAPI implements GroupsApiInterface {
    /**
     * 
     * @summary Get group by id (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).apiGroupsGroupIdGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Same as /groups (alias for convenience)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiMeGroupsGet(options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).apiMeGroupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new group
     * @param {GroupCreateRequest} groupCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGroup(groupCreateRequest: GroupCreateRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(groupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List groups where current user is a member (via linked participant)
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGroups(limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroups(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MatchesApi - axios parameter creator
 */
export const MatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List matches in group (member-only)
         * @param {string} groupId 
         * @param {string} [from] Filter by start time (inclusive)
         * @param {string} [to] Filter by start time (exclusive)
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdMatchesGet: async (groupId: string, from?: string, to?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdMatchesGet', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/matches`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete match result (admin-only)
         * @param {string} groupId 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdMatchesMatchIdDelete: async (groupId: string, matchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdMatchesMatchIdDelete', 'groupId', groupId)
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('apiGroupsGroupIdMatchesMatchIdDelete', 'matchId', matchId)
            const localVarPath = `/api/groups/{groupId}/matches/{matchId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update match result (admin-only)
         * @param {string} groupId 
         * @param {string} matchId 
         * @param {MatchUpdateRequest} matchUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdMatchesMatchIdPatch: async (groupId: string, matchId: string, matchUpdateRequest: MatchUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdMatchesMatchIdPatch', 'groupId', groupId)
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('apiGroupsGroupIdMatchesMatchIdPatch', 'matchId', matchId)
            // verify required parameter 'matchUpdateRequest' is not null or undefined
            assertParamExists('apiGroupsGroupIdMatchesMatchIdPatch', 'matchUpdateRequest', matchUpdateRequest)
            const localVarPath = `/api/groups/{groupId}/matches/{matchId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supports singles and doubles.
         * @summary Create match result (admin-only)
         * @param {string} groupId 
         * @param {MatchCreateRequest} matchCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdMatchesPost: async (groupId: string, matchCreateRequest: MatchCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdMatchesPost', 'groupId', groupId)
            // verify required parameter 'matchCreateRequest' is not null or undefined
            assertParamExists('apiGroupsGroupIdMatchesPost', 'matchCreateRequest', matchCreateRequest)
            const localVarPath = `/api/groups/{groupId}/matches`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchesApi - functional programming interface
 */
export const MatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List matches in group (member-only)
         * @param {string} groupId 
         * @param {string} [from] Filter by start time (inclusive)
         * @param {string} [to] Filter by start time (exclusive)
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdMatchesGet(groupId: string, from?: string, to?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdMatchesGet(groupId, from, to, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.apiGroupsGroupIdMatchesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete match result (admin-only)
         * @param {string} groupId 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdMatchesMatchIdDelete(groupId: string, matchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdMatchesMatchIdDelete(groupId, matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.apiGroupsGroupIdMatchesMatchIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update match result (admin-only)
         * @param {string} groupId 
         * @param {string} matchId 
         * @param {MatchUpdateRequest} matchUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdMatchesMatchIdPatch(groupId: string, matchId: string, matchUpdateRequest: MatchUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Match>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdMatchesMatchIdPatch(groupId, matchId, matchUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.apiGroupsGroupIdMatchesMatchIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Supports singles and doubles.
         * @summary Create match result (admin-only)
         * @param {string} groupId 
         * @param {MatchCreateRequest} matchCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdMatchesPost(groupId: string, matchCreateRequest: MatchCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Match>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdMatchesPost(groupId, matchCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.apiGroupsGroupIdMatchesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MatchesApi - factory interface
 */
export const MatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchesApiFp(configuration)
    return {
        /**
         * 
         * @summary List matches in group (member-only)
         * @param {string} groupId 
         * @param {string} [from] Filter by start time (inclusive)
         * @param {string} [to] Filter by start time (exclusive)
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdMatchesGet(groupId: string, from?: string, to?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<MatchPage> {
            return localVarFp.apiGroupsGroupIdMatchesGet(groupId, from, to, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete match result (admin-only)
         * @param {string} groupId 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdMatchesMatchIdDelete(groupId: string, matchId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiGroupsGroupIdMatchesMatchIdDelete(groupId, matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update match result (admin-only)
         * @param {string} groupId 
         * @param {string} matchId 
         * @param {MatchUpdateRequest} matchUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdMatchesMatchIdPatch(groupId: string, matchId: string, matchUpdateRequest: MatchUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Match> {
            return localVarFp.apiGroupsGroupIdMatchesMatchIdPatch(groupId, matchId, matchUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Supports singles and doubles.
         * @summary Create match result (admin-only)
         * @param {string} groupId 
         * @param {MatchCreateRequest} matchCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdMatchesPost(groupId: string, matchCreateRequest: MatchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Match> {
            return localVarFp.apiGroupsGroupIdMatchesPost(groupId, matchCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchesApi - interface
 */
export interface MatchesApiInterface {
    /**
     * 
     * @summary List matches in group (member-only)
     * @param {string} groupId 
     * @param {string} [from] Filter by start time (inclusive)
     * @param {string} [to] Filter by start time (exclusive)
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdMatchesGet(groupId: string, from?: string, to?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<MatchPage>;

    /**
     * 
     * @summary Delete match result (admin-only)
     * @param {string} groupId 
     * @param {string} matchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdMatchesMatchIdDelete(groupId: string, matchId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update match result (admin-only)
     * @param {string} groupId 
     * @param {string} matchId 
     * @param {MatchUpdateRequest} matchUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdMatchesMatchIdPatch(groupId: string, matchId: string, matchUpdateRequest: MatchUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Match>;

    /**
     * Supports singles and doubles.
     * @summary Create match result (admin-only)
     * @param {string} groupId 
     * @param {MatchCreateRequest} matchCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdMatchesPost(groupId: string, matchCreateRequest: MatchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Match>;

}

/**
 * MatchesApi - object-oriented interface
 */
export class MatchesApi extends BaseAPI implements MatchesApiInterface {
    /**
     * 
     * @summary List matches in group (member-only)
     * @param {string} groupId 
     * @param {string} [from] Filter by start time (inclusive)
     * @param {string} [to] Filter by start time (exclusive)
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdMatchesGet(groupId: string, from?: string, to?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).apiGroupsGroupIdMatchesGet(groupId, from, to, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete match result (admin-only)
     * @param {string} groupId 
     * @param {string} matchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdMatchesMatchIdDelete(groupId: string, matchId: string, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).apiGroupsGroupIdMatchesMatchIdDelete(groupId, matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update match result (admin-only)
     * @param {string} groupId 
     * @param {string} matchId 
     * @param {MatchUpdateRequest} matchUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdMatchesMatchIdPatch(groupId: string, matchId: string, matchUpdateRequest: MatchUpdateRequest, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).apiGroupsGroupIdMatchesMatchIdPatch(groupId, matchId, matchUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supports singles and doubles.
     * @summary Create match result (admin-only)
     * @param {string} groupId 
     * @param {MatchCreateRequest} matchCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdMatchesPost(groupId: string, matchCreateRequest: MatchCreateRequest, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).apiGroupsGroupIdMatchesPost(groupId, matchCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParticipantsApi - axios parameter creator
 */
export const ParticipantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List participants in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsGet', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/participants`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsParticipantIdDelete: async (groupId: string, participantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsParticipantIdDelete', 'groupId', groupId)
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsParticipantIdDelete', 'participantId', participantId)
            const localVarPath = `/api/groups/{groupId}/participants/{participantId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Binds a registered user (by id) to a participant entry in a group. Useful when participant was created before user registration. 
         * @summary Link registered user to participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {LinkUserRequest} linkUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsParticipantIdLinkUserPost: async (groupId: string, participantId: string, linkUserRequest: LinkUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsParticipantIdLinkUserPost', 'groupId', groupId)
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsParticipantIdLinkUserPost', 'participantId', participantId)
            // verify required parameter 'linkUserRequest' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsParticipantIdLinkUserPost', 'linkUserRequest', linkUserRequest)
            const localVarPath = `/api/groups/{groupId}/participants/{participantId}/link-user`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {ParticipantUpdateRequest} participantUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsParticipantIdPatch: async (groupId: string, participantId: string, participantUpdateRequest: ParticipantUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsParticipantIdPatch', 'groupId', groupId)
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsParticipantIdPatch', 'participantId', participantId)
            // verify required parameter 'participantUpdateRequest' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsParticipantIdPatch', 'participantUpdateRequest', participantUpdateRequest)
            const localVarPath = `/api/groups/{groupId}/participants/{participantId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(participantUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search participants by name with pagination. Results are sorted alphabetically. Returns paginated list of participants matching the query. 
         * @summary Search participants in group with pagination (member-only)
         * @param {string} groupId 
         * @param {string} [query] Search query (filters by name, case-insensitive)
         * @param {number} [page] Page number (0-based)
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsSearchGet: async (groupId: string, query?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsSearchGet', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/participants/search`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create participant (admin-only)
         * @param {string} groupId 
         * @param {ParticipantCreateRequest} participantCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsSearchPost: async (groupId: string, participantCreateRequest: ParticipantCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsSearchPost', 'groupId', groupId)
            // verify required parameter 'participantCreateRequest' is not null or undefined
            assertParamExists('apiGroupsGroupIdParticipantsSearchPost', 'participantCreateRequest', participantCreateRequest)
            const localVarPath = `/api/groups/{groupId}/participants/search`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(participantCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParticipantsApi - functional programming interface
 */
export const ParticipantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParticipantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List participants in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdParticipantsGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Participant>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdParticipantsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.apiGroupsGroupIdParticipantsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdParticipantsParticipantIdDelete(groupId: string, participantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdParticipantsParticipantIdDelete(groupId, participantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.apiGroupsGroupIdParticipantsParticipantIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Binds a registered user (by id) to a participant entry in a group. Useful when participant was created before user registration. 
         * @summary Link registered user to participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {LinkUserRequest} linkUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdParticipantsParticipantIdLinkUserPost(groupId: string, participantId: string, linkUserRequest: LinkUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdParticipantsParticipantIdLinkUserPost(groupId, participantId, linkUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.apiGroupsGroupIdParticipantsParticipantIdLinkUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {ParticipantUpdateRequest} participantUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdParticipantsParticipantIdPatch(groupId: string, participantId: string, participantUpdateRequest: ParticipantUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdParticipantsParticipantIdPatch(groupId, participantId, participantUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.apiGroupsGroupIdParticipantsParticipantIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search participants by name with pagination. Results are sorted alphabetically. Returns paginated list of participants matching the query. 
         * @summary Search participants in group with pagination (member-only)
         * @param {string} groupId 
         * @param {string} [query] Search query (filters by name, case-insensitive)
         * @param {number} [page] Page number (0-based)
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdParticipantsSearchGet(groupId: string, query?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParticipantSearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdParticipantsSearchGet(groupId, query, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.apiGroupsGroupIdParticipantsSearchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create participant (admin-only)
         * @param {string} groupId 
         * @param {ParticipantCreateRequest} participantCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdParticipantsSearchPost(groupId: string, participantCreateRequest: ParticipantCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdParticipantsSearchPost(groupId, participantCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.apiGroupsGroupIdParticipantsSearchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParticipantsApi - factory interface
 */
export const ParticipantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParticipantsApiFp(configuration)
    return {
        /**
         * 
         * @summary List participants in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Participant>> {
            return localVarFp.apiGroupsGroupIdParticipantsGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsParticipantIdDelete(groupId: string, participantId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiGroupsGroupIdParticipantsParticipantIdDelete(groupId, participantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Binds a registered user (by id) to a participant entry in a group. Useful when participant was created before user registration. 
         * @summary Link registered user to participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {LinkUserRequest} linkUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsParticipantIdLinkUserPost(groupId: string, participantId: string, linkUserRequest: LinkUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.apiGroupsGroupIdParticipantsParticipantIdLinkUserPost(groupId, participantId, linkUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update participant (admin-only)
         * @param {string} groupId 
         * @param {string} participantId 
         * @param {ParticipantUpdateRequest} participantUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsParticipantIdPatch(groupId: string, participantId: string, participantUpdateRequest: ParticipantUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.apiGroupsGroupIdParticipantsParticipantIdPatch(groupId, participantId, participantUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search participants by name with pagination. Results are sorted alphabetically. Returns paginated list of participants matching the query. 
         * @summary Search participants in group with pagination (member-only)
         * @param {string} groupId 
         * @param {string} [query] Search query (filters by name, case-insensitive)
         * @param {number} [page] Page number (0-based)
         * @param {number} [pageSize] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsSearchGet(groupId: string, query?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<ParticipantSearchResult> {
            return localVarFp.apiGroupsGroupIdParticipantsSearchGet(groupId, query, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create participant (admin-only)
         * @param {string} groupId 
         * @param {ParticipantCreateRequest} participantCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdParticipantsSearchPost(groupId: string, participantCreateRequest: ParticipantCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.apiGroupsGroupIdParticipantsSearchPost(groupId, participantCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParticipantsApi - interface
 */
export interface ParticipantsApiInterface {
    /**
     * 
     * @summary List participants in group (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdParticipantsGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Participant>>;

    /**
     * 
     * @summary Delete participant (admin-only)
     * @param {string} groupId 
     * @param {string} participantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdParticipantsParticipantIdDelete(groupId: string, participantId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Binds a registered user (by id) to a participant entry in a group. Useful when participant was created before user registration. 
     * @summary Link registered user to participant (admin-only)
     * @param {string} groupId 
     * @param {string} participantId 
     * @param {LinkUserRequest} linkUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdParticipantsParticipantIdLinkUserPost(groupId: string, participantId: string, linkUserRequest: LinkUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant>;

    /**
     * 
     * @summary Update participant (admin-only)
     * @param {string} groupId 
     * @param {string} participantId 
     * @param {ParticipantUpdateRequest} participantUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdParticipantsParticipantIdPatch(groupId: string, participantId: string, participantUpdateRequest: ParticipantUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant>;

    /**
     * Search participants by name with pagination. Results are sorted alphabetically. Returns paginated list of participants matching the query. 
     * @summary Search participants in group with pagination (member-only)
     * @param {string} groupId 
     * @param {string} [query] Search query (filters by name, case-insensitive)
     * @param {number} [page] Page number (0-based)
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdParticipantsSearchGet(groupId: string, query?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<ParticipantSearchResult>;

    /**
     * 
     * @summary Create participant (admin-only)
     * @param {string} groupId 
     * @param {ParticipantCreateRequest} participantCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdParticipantsSearchPost(groupId: string, participantCreateRequest: ParticipantCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Participant>;

}

/**
 * ParticipantsApi - object-oriented interface
 */
export class ParticipantsApi extends BaseAPI implements ParticipantsApiInterface {
    /**
     * 
     * @summary List participants in group (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdParticipantsGet(groupId: string, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).apiGroupsGroupIdParticipantsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete participant (admin-only)
     * @param {string} groupId 
     * @param {string} participantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdParticipantsParticipantIdDelete(groupId: string, participantId: string, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).apiGroupsGroupIdParticipantsParticipantIdDelete(groupId, participantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Binds a registered user (by id) to a participant entry in a group. Useful when participant was created before user registration. 
     * @summary Link registered user to participant (admin-only)
     * @param {string} groupId 
     * @param {string} participantId 
     * @param {LinkUserRequest} linkUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdParticipantsParticipantIdLinkUserPost(groupId: string, participantId: string, linkUserRequest: LinkUserRequest, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).apiGroupsGroupIdParticipantsParticipantIdLinkUserPost(groupId, participantId, linkUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update participant (admin-only)
     * @param {string} groupId 
     * @param {string} participantId 
     * @param {ParticipantUpdateRequest} participantUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdParticipantsParticipantIdPatch(groupId: string, participantId: string, participantUpdateRequest: ParticipantUpdateRequest, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).apiGroupsGroupIdParticipantsParticipantIdPatch(groupId, participantId, participantUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search participants by name with pagination. Results are sorted alphabetically. Returns paginated list of participants matching the query. 
     * @summary Search participants in group with pagination (member-only)
     * @param {string} groupId 
     * @param {string} [query] Search query (filters by name, case-insensitive)
     * @param {number} [page] Page number (0-based)
     * @param {number} [pageSize] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdParticipantsSearchGet(groupId: string, query?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).apiGroupsGroupIdParticipantsSearchGet(groupId, query, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create participant (admin-only)
     * @param {string} groupId 
     * @param {ParticipantCreateRequest} participantCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdParticipantsSearchPost(groupId: string, participantCreateRequest: ParticipantCreateRequest, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).apiGroupsGroupIdParticipantsSearchPost(groupId, participantCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RatingsApi - axios parameter creator
 */
export const RatingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Doubles Elo leaderboard in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdRatingsDoublesGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdRatingsDoublesGet', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/ratings/doubles`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Singles Elo leaderboard in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdRatingsSinglesGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdRatingsSinglesGet', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/ratings/singles`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Current user ratings (singles + doubles)
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeRatingsGet: async (groupId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingsApi - functional programming interface
 */
export const RatingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Doubles Elo leaderboard in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdRatingsDoublesGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RatingRowDoubles>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdRatingsDoublesGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingsApi.apiGroupsGroupIdRatingsDoublesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Singles Elo leaderboard in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdRatingsSinglesGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RatingRowSingles>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdRatingsSinglesGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingsApi.apiGroupsGroupIdRatingsSinglesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Current user ratings (singles + doubles)
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeRatingsGet(groupId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRatings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeRatingsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingsApi.apiMeRatingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RatingsApi - factory interface
 */
export const RatingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Doubles Elo leaderboard in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdRatingsDoublesGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RatingRowDoubles>> {
            return localVarFp.apiGroupsGroupIdRatingsDoublesGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Singles Elo leaderboard in group (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdRatingsSinglesGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RatingRowSingles>> {
            return localVarFp.apiGroupsGroupIdRatingsSinglesGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Current user ratings (singles + doubles)
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeRatingsGet(groupId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserRatings> {
            return localVarFp.apiMeRatingsGet(groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RatingsApi - interface
 */
export interface RatingsApiInterface {
    /**
     * 
     * @summary Doubles Elo leaderboard in group (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdRatingsDoublesGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RatingRowDoubles>>;

    /**
     * 
     * @summary Singles Elo leaderboard in group (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdRatingsSinglesGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RatingRowSingles>>;

    /**
     * 
     * @summary Current user ratings (singles + doubles)
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMeRatingsGet(groupId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserRatings>;

}

/**
 * RatingsApi - object-oriented interface
 */
export class RatingsApi extends BaseAPI implements RatingsApiInterface {
    /**
     * 
     * @summary Doubles Elo leaderboard in group (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdRatingsDoublesGet(groupId: string, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).apiGroupsGroupIdRatingsDoublesGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Singles Elo leaderboard in group (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdRatingsSinglesGet(groupId: string, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).apiGroupsGroupIdRatingsSinglesGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Current user ratings (singles + doubles)
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiMeRatingsGet(groupId?: string, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).apiMeRatingsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatsApi - axios parameter creator
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Group stats (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdStatsGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiGroupsGroupIdStatsGet', 'groupId', groupId)
            const localVarPath = `/api/groups/{groupId}/stats`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns detailed stats including recent matches list
         * @summary Current user game statistics with recent matches
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGamesStatsGet: async (groupId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me/games-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Current user stats across all groups (or filter by group)
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeStatsGet: async (groupId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Group stats (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupsGroupIdStatsGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupsGroupIdStatsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.apiGroupsGroupIdStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns detailed stats including recent matches list
         * @summary Current user game statistics with recent matches
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeGamesStatsGet(groupId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGamesStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeGamesStatsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.apiMeGamesStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Current user stats across all groups (or filter by group)
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeStatsGet(groupId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeStatsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.apiMeStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatsApi - factory interface
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * 
         * @summary Group stats (member-only)
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupsGroupIdStatsGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupStats> {
            return localVarFp.apiGroupsGroupIdStatsGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns detailed stats including recent matches list
         * @summary Current user game statistics with recent matches
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGamesStatsGet(groupId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserGamesStats> {
            return localVarFp.apiMeGamesStatsGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Current user stats across all groups (or filter by group)
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeStatsGet(groupId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStats> {
            return localVarFp.apiMeStatsGet(groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - interface
 */
export interface StatsApiInterface {
    /**
     * 
     * @summary Group stats (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiGroupsGroupIdStatsGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupStats>;

    /**
     * Returns detailed stats including recent matches list
     * @summary Current user game statistics with recent matches
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMeGamesStatsGet(groupId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserGamesStats>;

    /**
     * 
     * @summary Current user stats across all groups (or filter by group)
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMeStatsGet(groupId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStats>;

}

/**
 * StatsApi - object-oriented interface
 */
export class StatsApi extends BaseAPI implements StatsApiInterface {
    /**
     * 
     * @summary Group stats (member-only)
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGroupsGroupIdStatsGet(groupId: string, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).apiGroupsGroupIdStatsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns detailed stats including recent matches list
     * @summary Current user game statistics with recent matches
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiMeGamesStatsGet(groupId?: string, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).apiMeGamesStatsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Current user stats across all groups (or filter by group)
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiMeStatsGet(groupId?: string, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).apiMeStatsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TelegramAuthApi - axios parameter creator
 */
export const TelegramAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logout current session (token revocation if supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate new access and refresh tokens using refresh token
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshRequest: RefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshRequest' is not null or undefined
            assertParamExists('refreshToken', 'refreshRequest', refreshRequest)
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns parameters for Telegram Login Widget and a nonce/state identifier. Client then completes Telegram login and submits payload to `/auth/telegram/complete`. 
         * @summary Login via Telegram authorization data
         * @param {TelegramUser} telegramUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramLogin: async (telegramUser: TelegramUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'telegramUser' is not null or undefined
            assertParamExists('telegramLogin', 'telegramUser', telegramUser)
            const localVarPath = `/api/auth/telegram/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(telegramUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelegramAuthApi - functional programming interface
 */
export const TelegramAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TelegramAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Logout current session (token revocation if supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelegramAuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate new access and refresh tokens using refresh token
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelegramAuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns parameters for Telegram Login Widget and a nonce/state identifier. Client then completes Telegram login and submits payload to `/auth/telegram/complete`. 
         * @summary Login via Telegram authorization data
         * @param {TelegramUser} telegramUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telegramLogin(telegramUser: TelegramUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telegramLogin(telegramUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TelegramAuthApi.telegramLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TelegramAuthApi - factory interface
 */
export const TelegramAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TelegramAuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Logout current session (token revocation if supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate new access and refresh tokens using refresh token
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.refreshToken(refreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns parameters for Telegram Login Widget and a nonce/state identifier. Client then completes Telegram login and submits payload to `/auth/telegram/complete`. 
         * @summary Login via Telegram authorization data
         * @param {TelegramUser} telegramUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telegramLogin(telegramUser: TelegramUser, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.telegramLogin(telegramUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelegramAuthApi - interface
 */
export interface TelegramAuthApiInterface {
    /**
     * 
     * @summary Logout current session (token revocation if supported)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Generate new access and refresh tokens using refresh token
     * @param {RefreshRequest} refreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;

    /**
     * Returns parameters for Telegram Login Widget and a nonce/state identifier. Client then completes Telegram login and submits payload to `/auth/telegram/complete`. 
     * @summary Login via Telegram authorization data
     * @param {TelegramUser} telegramUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    telegramLogin(telegramUser: TelegramUser, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;

}

/**
 * TelegramAuthApi - object-oriented interface
 */
export class TelegramAuthApi extends BaseAPI implements TelegramAuthApiInterface {
    /**
     * 
     * @summary Logout current session (token revocation if supported)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(options?: RawAxiosRequestConfig) {
        return TelegramAuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate new access and refresh tokens using refresh token
     * @param {RefreshRequest} refreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig) {
        return TelegramAuthApiFp(this.configuration).refreshToken(refreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns parameters for Telegram Login Widget and a nonce/state identifier. Client then completes Telegram login and submits payload to `/auth/telegram/complete`. 
     * @summary Login via Telegram authorization data
     * @param {TelegramUser} telegramUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public telegramLogin(telegramUser: TelegramUser, options?: RawAxiosRequestConfig) {
        return TelegramAuthApiFp(this.configuration).telegramLogin(telegramUser, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 */
export interface UsersApiInterface {
    /**
     * 
     * @summary Current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User>;

}

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @summary Current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }
}



